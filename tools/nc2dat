#!/usr/bin/env python3
"""
Qing Li, 20171103
"""
import sys
import argparse
import datetime
import numpy as np
from netCDF4 import Dataset, num2date, date2index
from gotmtool import nctime_to_datetime, nctime_indices

def main():
    # process the input arguments
    parser = argparse.ArgumentParser(description="""
            Read a netCDF file and output variables in a text file in the GOTM
            input file format. Currently support time series of surface fluxes
            and time series of vertical profiles.""")
    parser.add_argument('-i', '--input', action='store', dest='fname_in',
            metavar='NCFILENAME', required=True, help='Input netCDF filename')
    parser.add_argument('-v', '--variable', action='store', dest='vname_in',
            metavar='VARNAME', required=True, nargs='+',
            help='Variable name in netCDF file, support multiple variables')
    parser.add_argument('-o', '--output', action='store', dest='fname_out',
            metavar='DATFILENAME', required=True, help='Output filename')
    parser.add_argument('-ds', '--date_start', action='store', dest='date_start',
            metavar='STARTDATE', required=True,
            help='Starting date of input data, in the format of YYYYMMDD')
    parser.add_argument('-de', '--date_end', action='store', dest='date_end',
            metavar='ENDDATE', required=True,
            help='Ending date of input data, in the format of YYYYMMDD')
    parser.add_argument('--version', action='version', version='%(prog)s: 1.1')
    # parsing arguments and save to args
    args=parser.parse_args()

    # print out some message
    print('Converting {} to {}...'.format(args.fname_in, args.fname_out))

    # read netCDF file
    infile = Dataset(args.fname_in, 'r')
    varlist = infile.variables.keys()
    attlist = infile.ncattrs()

    # read time dimension
    if 'time' in varlist:
        nctime = infile.variables['time']
    elif 'TIME' in varlist:
        nctime = infile.variables['TIME']
    else:
        print('Time dimension is required and should have the name \"time\" or \"TIME\"')
        sys.exit(1)

    dttime = nctime_to_datetime(nctime) # time in datetime format

    # get starting and ending indices
    tidx_start, tidx_end = nctime_indices(nctime, args.date_start,
            args.date_end)
    tdat = [dttime[i].isoformat(' ', 'seconds')
            for i in range(tidx_start, tidx_end+1)] # truncated to seconds
    # TODO isoformat() takes only one arguments in py35:  <06-11-17, Qing Li> #
    # get depth
    if 'depth' in varlist:
        ddat = infile.variables['depth'][:]
    elif 'DEPTH' in varlist:
        ddat = infile.variables['DEPTH'][:]
    else:
        ddat = 0.0

    nd = ddat.size
    ddat = -abs(ddat)

    # get global missing value
    if 'missing_value' in attlist:
        gmvalue = infile.missing_value
    elif '_FillValue' in attlist:
        gmvalue = infile._FillValue
    else:
        # turn off auto mask, handled in write_pfl()
        infile.set_auto_mask(False)
        gmvalue = np.nan

    # read variables
    vdat = []    # a list of arrays, an array for each variable
    for vname in args.vname_in:
        vdat.append(ncread(infile, vname,
            tidxstart=tidx_start, tidxend=tidx_end+1))

    # write to output file
    if nd == 1:
        # write time series
        write_ts(args.fname_out, tdat, vdat, mask=gmvalue)
    else:
        # write profiles
        write_pfl(args.fname_out, tdat, ddat, vdat, mask=gmvalue)

def write_ts(fnout, tdat, vdat, mask=None):
    """Write time series.

    :fnout: (str) filename of output file
    :tdat: (list) array of time
    :vdat: (list) array of variables
    :mask: (float, optional) value in vdat to skip
    :returns: none

    """
    nt = len(tdat)   # size of time
    with open(fnout, 'w') as fout:
        if mask is None:
            # no mask is applied
            for i in range(nt):
                # time
                out_str = '{}'.format(tdat[i])
                # variables
                for var in vdat:
                    out_str += '  {:6.2f}'.format(var[i])
                # newline
                out_str += '\n'
                fout.write(out_str)
        else:
            # skip if the value of any variable matches the mask value
            # or is NaN
            for i in range(nt):
                if not any(var[i] == mask or np.isnan(var[i]) for var in vdat):
                    # time
                    out_str = '{}'.format(tdat[i])
                    # variables
                    for var in vdat:
                        out_str += '  {:6.2f}'.format(var[i])
                    # newline
                    out_str += '\n'
                    fout.write(out_str)

def write_pfl(fnout, tdat, ddat, vdat, mask=None):
    """Write time series of profile.

    :fnout: (str) filename of output file
    :tdat: (list) array of time
    :ddat: (list) array of depth
    :vdat: (list) array of variables
    :mask: (float, optional) value in vdat to skip
    :returns: none

    """
    nt = len(tdat[:]) # size of time
    nd = len(ddat[:]) # size of depth
    up_down = 2 # 1: data written from bottom to top (z<0 increasing)
                # otherwise: data written from top to bottom (z<0 decreasing)
    with open(fnout, 'w') as fout:
        if mask is None:
            # no mask is applied
            for i in range(nt):
                # time and dimension size
                out_str = '{}  {}  {}\n'.format(tdat[i], nd, up_down)
                fout.write(out_str)
                for j in range(nd):
                    # depth
                    out_str = '{:7.1f}'.format(ddat[j])
                    # variables
                    for var in vdat:
                        out_str += '  {:10.6f}'.format(var[i,j])
                    # newline
                    out_str += '\n'
                    fout.write(out_str)
        else:
            # skip the depth if the value of any variable matches the mask value
            # or is NaN
            for i in range(nt):
                fidx = []   # indices of filtered depth
                for j in range(nd):
                    if any(var[i,j] == mask or np.isnan(var[i,j]) for var in vdat):
                        fidx.append(j)
                nskip = len(fidx) # number of skipped depth
                if nd-nskip > 0:
                    # skip if there is no available data to write
                    # time and dimension size
                    out_str = '{}  {}  {}\n'.format(tdat[i], nd-nskip, up_down)
                    fout.write(out_str)
                    for j in range(nd):
                        if j not in fidx:
                            # depth
                            out_str = '{:7.1f}'.format(ddat[j])
                            # variables
                            for var in vdat:
                                out_str += '  {:10.6f}'.format(var[i,j])
                            # newline
                            out_str += '\n'
                            fout.write(out_str)


def ncread(infile, *argv, tidxstart=None, tidxend=None):
    """Read variables from a netCDF file.

    :infile: (netCDF4 Dateset) input netCDF file
    :*argv: (str) name of variables to read
    :tidxstart: (int) start time index
    :tidxend: (int) end time index
    :returns: (list) value or netCDF object of requested variable

    """
    nargv = len(argv)
    rdat = []
    for vname in argv:
        dat = infile.variables[vname]
        nsize = dat.ndim
        if tidxstart is not None and tidxend is not None:
            if nsize == 4:
                odat = dat[tidxstart:tidxend,:,:,:]
            elif nsize == 2:
                odat = dat[tidxstart:tidxend,:]
            elif nsize == 1:
                odat = dat[tidxstart:tidxend]
            else:
                print('The variable {} has {} dimension, not supported'
                        .format(vname, nsize))
                sys.exit(1)
        else:
            odat = dat[:]
        # append to var list
        rdat.append(np.squeeze(odat))

    # return a list of arrays if more than one variable are requested
    if len(rdat) == 1:
        return rdat[0]
    else:
        return rdat

if __name__ == "__main__":
    main()
