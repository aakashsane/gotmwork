#!/usr/bin/env python3
"""
Qing Li, 20171213
"""

import matplotlib.pyplot as plt
import numpy as np
from netCDF4 import Dataset, num2date
import argparse
import sys
from gotmtool import get_start_end_indices

def main():
    # process input arguments
    parser = argparse.ArgumentParser(description="""
        Plot time series of profile from GOTM together with the observation.""")
    parser.add_argument('-f', '--file', action='store', dest='fname',
            metavar='FILENAME', help='Input GOTM data')
    parser.add_argument('-v', '--variable', action='store', dest='vname',
            metavar='VARNAME', help='Variable name')
    parser.add_argument('-o', '--output', action='store', dest='fname_out',
            metavar='FIGNAME', help='Output figure name')
    parser.add_argument('-obs', '--obs', action='store_true', dest='lobs',
            help='Also plot data from the observation.')
    parser.add_argument('-ds', '--date_start', action='store', dest='date_start',
            metavar='STARTDATE',
            help='Starting date of input data, in the format of YYYYMMDD')
    parser.add_argument('-de', '--date_end', action='store', dest='date_end',
            metavar='ENDDATE',
            help='Ending date of input data, in the format of YYYYMMDD')
    parser.add_argument('--version', action='version', version='%(prog)s: 1.0')
    # parsing arguments and save to args
    args = parser.parse_args()

    # check input
    if not args.fname or not args.vname:
        print('GOTM netCDF data, variable name, and output figure name are required. Stop.\n')
        parser.print_help()
        sys.exit(1)

    # read data
    fin = Dataset(args.fname, 'r')
    nctime = fin.variables['time']
    dim_time = len(nctime[:])
    ncvar = fin.variables[args.vname]

    # choose veritcal coordinate
    coord = ncvar.coordinates
    if 'zi' in coord:
        z = fin.variables['zi'][0,:,0,0]
    else:
        z = fin.variables['z'][0,:,0,0]

    # get starting and ending indices
    tidx_start, tidx_end = get_start_end_indices(nctime, args.date_start,
            args.date_end)

    # nctime -> datetime
    dttime = num2date(nctime[tidx_start:tidx_end], units=nctime.units,
            calendar=nctime.calendar)
    mdl = ncvar[tidx_start:tidx_end,:,0,0]

    # if plot obs
    l_plot_obs = args.lobs
    if l_plot_obs:
        try:
            obs = fin.variables[args.vname+'_obs'][tidx_start:tidx_end,:,0,0]
        except KeyError:
            print('Observation \'{}\' not exist. Skip option \'--obs\'.'
                    .format(args.vname+'_obs'))
            l_plot_obs = False

    # get levels
    levels = set_levels(mdl)

    # subplot, share x axis
    if l_plot_obs:
        fig_height = 4
        fig, axarr = plt.subplots(2, sharex=True)
        im1 = axarr[0].contourf(dttime, z, np.transpose(obs), levels,
                extend='both')
        im2 = axarr[1].contourf(dttime, z, np.transpose(mdl), levels,
                extend='both')
        # auto adjust the x-axis label
        plt.gcf().autofmt_xdate()
        axarr[0].set_ylabel('Depth (m)')
        axarr[1].set_ylabel('Depth (m)')
        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.83, 0.18, 0.02, 0.72])
        cb = fig.colorbar(im2, cax=cbar_ax)
    else:
        fig_height = 3
        im = plt.contourf(dttime, z, np.transpose(mdl), levels,
                extend='both')
        # auto adjust the x-axis label
        plt.gcf().autofmt_xdate()
        plt.ylabel('Depth (m)')
        cb = plt.colorbar(im)

    # scientific notation for colorbar labels
    cb.formatter.set_powerlimits((-2, 2))
    cb.update_ticks()


    # set figure size
    fig_width = 6
    f = plt.gcf()
    f.set_size_inches(fig_width, fig_height)

    # save figure
    if args.fname_out:
        figname = args.fname_out+'.pdf'
    else:
        figname = args.vname+'.pdf'

    plt.savefig(figname)

def set_levels(data):
    """Set contour levels by the 99th and 1st percentiles of the data.

    :data: (list, numpy array) array of data

    """
    # round off
    c_max = float(format(np.percentile(data, 99), '.1e'))
    c_min = float(format(np.percentile(data, 1), '.1e'))
    dsub = 0
    # if c_max equals c_min, check more digits
    if c_max == c_min:
        data_new = data
        while c_max == c_min:
            dsub +=c_max
            data_new = data_new-c_max
            c_max = float(format(np.percentile(data_new, 99), '.1e'))
            c_min = float(format(np.percentile(data_new, 1), '.1e'))
    # set 20 levels
    c_int = (c_max-c_min)/20
    levels = np.arange(c_min, c_max+c_int, c_int)+dsub
    return levels

if __name__ == "__main__":
    main()
